# 事件流、事件代理、事件委托
https://blog.csdn.net/XH_jing/article/details/135773091


事件委托是一个叫法，例如上面的例子，ul 为 li 代理 click 事件，这就叫做事件代理。也可以说是 li 将 click 事件委托给 ul，这就叫做事件委托。

所以当面试官问你事件委托和事件代理的区别，千万不要蒙了，这俩其实是一个东西。

事件流是为了解决处理事件的顺序问题

比如当点击按钮，认为点击事件不仅仅发生在按钮上，甚至也点击了整个页面，所以是先处理谁呢？

- 事件冒泡是 IE 团队提出的事件流方案（认为处理最具体元素，再往上冒泡到根）
- 事件捕获是 网景 团队提出的事件流解决方案（与冒泡相反）

1. **事件捕获阶段**：事件从上往下查找对应元素，直到捕获到事件
2. **处于目标阶段**：目标元素后执行事件对应的处理函数
3. **事件冒泡阶段**：事件从目标元素开始冒泡

事件处理程序就是当事件发生的时候做出的反应

DOM 分三个Level 012 

- DOM0 事件处理
- （a.**onclick** = 回调函数的方式绑定事件处理程序）(this 指向该元素本身)
- 将事件处理程序属性设置为 null，即可移除通过 DOM0 方式添加的事件处理程序
- 有多个 DOM0 事件处理程序的话，后面的是会把前面的给覆盖掉
- 发生在事件流的冒泡阶段的调用

- DOM2 事件处理
- 通过调用 **addEventListener**() 和 **removeEventLinstener**() 来添加和移除事件处理程序，默认在冒泡阶段调用，通过设置参数 useCapture 设置为 true 表示在捕获阶段调用

- DOM3级事件处理
- 添加了更多的事件类型
- 允许使用者自定义一些事件

事件处理函数回调拿到的 Event 对象，常见属性：

- bubbles（是否可冒泡）：focus，scroll，onblur（当一个元素失去焦点的时候 blur 事件被触发。） 不支持冒泡
- stopPropgation: 停止冒泡和捕获
- stopImmediatePropgation：停止后还能阻值其他监听函数被调用
- target: 触发元素
- currentTarget: 绑定处理函数元素
- preventDefault()：阻值默认行为
	- return false

基于事件冒泡可以实现事件委托，在父节点设置事件处理程序，就可以在事件处理程序逻辑里面分别处理不同子节点的处理逻辑，或者统一处理。react 合成事件就是基于这个特性来实现的