# Cracking the Coding Interview 6th Edition

破解编码面试 ：Cracking the Coding Interview: 189 Programming Questions and Solutions

简单的问题并不会让你更容易获得 offer。获得 offer 并不是要求你能完美地解决问题（很少有求职者能够做到！），而是要求你能给出比其他的求职者更好的回答。所以，当你遇到棘手的问题时，不要紧张——其他人可能都认为它很难。做不到完美也没有关系。

算法和编码问题是面试过程中最大的组成部分。这类问题都可以被视为问题解决型（problem-solving）的问题。面试官希望能通过观察你解决以前没有遇到过的算法问题的过程，来评估你的能力。在整个解决问题的过程中，你应该大声地说出你的方案，并解释你的思考过程。你的面试官有时会跳出来引导你，让他们这样做。这是正常的，并不意味着你做得很差。(当然，不需要提示就更好了。)

你的面试官对你的表现进行评估，通常是基于以下几点：

- **分析能力**：你需要很多帮助来解决问题吗？你的解决方案有多优？你花了多长时间才找到解决办法？如果你必须设计/架构一个新的解决方案，你是否很好地组织了问题并考虑了不同决策的权衡？
    
- **编码水平**：你是否能够将算法成功转换为合理的代码？它干净有序吗？你是否考虑过潜在的错误？ 你的代码风格好吗？
    
- **技术知识/计算机科学基础知识**：你是否拥有计算机科学和相关技术的坚实基础？
    
- **经验**：你过去做过很好的技术决策吗？你做过有趣、有挑战性的项目吗？你是否表现出动力、主动性和其他重要因素？
    
- **文化契合/沟通技巧**：你的个性和价值观是否与公司和团队契合？你和面试官是否能够良好沟通？

不同公司之间存在着一些广泛的差异。一些公司专注于算法（通常被用于一些系统设计），而另一些公司则非常喜欢基于知识的问题。但在一个给定的问题类别中，几乎没有什么能让它“属于”一家公司，而不是另一家公司。

你的表现是相对于其他候选人来判断的，它不是基于简单的“正确百分比”来评估的。


专注于自己，而不是团队

面试从根本上说是个人评估。不幸的是，当你倾听许多候选人（尤其是那些担任领导职务的候选人）的回答时，他们的答案往往是关于“我们”和“团队”的。面试官离开的时候对候选人的实际影响一无所知，可能会得出这样的结论：候选人没有做任何事情。

注意你的答案。听一听相对于“我”，你说了多少次“我们”。所以请假设每个问题都是关于你的角色的，然后再说出来。


给出有条理的答案
有两种常见的方法来考虑如何组织对行为问题的回答：金块优先（Nugget First），和S.A.R. 。这些技术可以单独使用，也可以一起使用。

金块优先（Nugget First）

“金块优先”是指从一个“金块”开始你的回答，该“金块”简洁地描述了你的回答是关于什么的。

例如：

面试官：“请给出一个你说服一群人做出巨大改变的例子。”
候选人：“好的，让我来告诉你一次我说服学校让本科生自己教授自己课程的经历。起初，我们学校有一条规定……”
这种技巧能抓住面试官的注意力，让你的故事内容一目了然。它还能帮助你更专注于你的交流，因为你已经非常清楚地告诉自己你回答的要点是什么。

S.A.R. 这种方法意味着你首先要概述情况，然后解释所采取的行动，最后描述结果。

**情况（Situation）**：**行动（Action）**：**结果（Result）**：


技术问题：

| **数据结构**                         | **算法**                        | **概念**                                 |
| -------------------------------- | ----------------------------- | -------------------------------------- |
| 链表 (Linked Lists)                | 广度优先搜索 (Breadth-First Search) | 位运算 (Bit Manipulation)                 |
| 树、前缀树和图 (Trees, Tries, & Graphs) | 深度优先搜索 (Depth-First Search)   | 内存 (栈 vs. 堆) (Memory - Stack vs. Heap) |
| 栈和队列 (Stacks & Queues)           | 二分查找 (Binary Search)          | 递归 (Recursion)                         |
| 堆 (Heaps)                        | 归并排序 (Merge Sort)             | 动态规划 (Dynamic Programming)             |
| 向量/动态数组 (Vectors / ArrayLists)   | 快速排序 (Quick Sort)             | 大 O 时间和空间 (Big O Time & Space)         |
| 哈希表 (Hash Tables)                |                               |                                        |

