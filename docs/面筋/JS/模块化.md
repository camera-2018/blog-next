模块化是为了解决变量全局污染和依赖管理混乱的问题

commonjs

- 所有代码都运行于模块作用域，不会污染全局。
- 使用同步的方式加载，也就是说，只有加载完成才能执行后面的操作。
- CommonJS 支持动态导入的方式，比如：require(`./${path}.js`)
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后加载结果会被缓存，后面再次加载会直接读取缓存结果，如果想让模块重新执行，就必须清除缓存。
- CommonJS 模块输出的是一个值的**拷贝**
- 模块的加载顺序，按照其在代码中出现的顺序。

esmodule：

- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";
- ESModule 导出的模块是只读的，不能变更，否则报错
- ESModule 输出的是值的**引用**
- 模块只会加载一次